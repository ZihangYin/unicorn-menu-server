package com.unicorn.rest.repository.table;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Singleton;

import com.unicorn.rest.repository.exception.DuplicateKeyException;
import com.unicorn.rest.repository.exception.ItemNotFoundException;
import com.unicorn.rest.repository.exception.RepositoryServerException;
import com.unicorn.rest.repository.exception.StaleDataException;
import com.unicorn.rest.repository.exception.ValidationException;
import com.unicorn.rest.repository.model.EmailAddress;

/**
 * TODO: JavaMail (http://www.oracle.com/technetwork/java/javamail/index.html)
 * sending email to verify the email address
 */
@Singleton
public interface EmailAddressToPrincipalTable extends Table {
    
    public static final String EMAIL_ADDRESS_TO_PRINCIPAL_TABLE_NAME = "EMAIL_ADDRESS_TO_PRINCIPAL_TABLE";
    /**
     * Create email_address to principal mapping in the email_address_to_id_table
     * The activate_in_epoch time is generated by server
     * 
     * @param emailAddress @Nullable
     * @param principal @Nullable
     * @throws ValidationException if request is invalid
     * @throws DuplicateKeyException if email_address is already mapped to existing principal
     * @throws RepositoryServerException internal server error
     */
    public void createEmailAddressForPrincipal(@Nullable EmailAddress emailAddress, @Nullable Long principal) 
            throws ValidationException, DuplicateKeyException, RepositoryServerException;
    
    /**
     * Get the current email_address to principal from email_address_to_id_table
     * create new email_address to principal mapping in the email_address_to_id_table
     * and delete the old email_address to principal mapping
     * 
     * Note:
     * This might encounter some problems when there exists concurrent update requests for the same user/customer
     * However, we consider this as a rare case
     * 
     * If the create operation succeeds yet the delete operation failed, there is a 
     * chance that user/customer will have multiple email_addresses to log in. 
     * However, we can still figure out which one is the latest by checking the activate_in_epoch 
     * 
     * @param curEmailAddress @Nullable
     * @param newEmailAddress @Nullable
     * @param principal @Nullable
     * @throws ValidationException if request is invalid
     * @throws DuplicateKeyException if new email_address is already mapped to existing principal   
     * @throws ItemNotFoundException if email_address attempted to deleted mapped to a different principal or principal does not exist
     * @throws RepositoryServerException internal server error
     */
    public void updateEmailAddressForPrincipal(@Nullable EmailAddress curEmailAddress, @Nullable EmailAddress newEmailAddress, @Nullable Long principal) 
            throws ValidationException, DuplicateKeyException, ItemNotFoundException, RepositoryServerException;
    
    /**
     * Get principal for given email_address
     * 
     * @param emailAddress @Nullable
     * @return
     * @throws ValidationException if request is invalid
     * @throws ItemNotFoundException if email_address does not exist in the table
     * @throws RepositoryServerException internal server error
     */
    public @Nonnull Long getPrincipal(@Nullable EmailAddress emailAddress) 
            throws ValidationException, ItemNotFoundException, RepositoryServerException;
    
    /**
     * Get email_address for principal.
     * 
     * Note:
     * Since principal-actiavet_in_epoch is global secondary index, there is currently no strong consistency.
     * meaning that there is a certain chance we will get stale data. 
     * However, we can check if the data is actually state by looking up the email address again.
     * What is more, since failure can happen when user/customer updates email_address (successfully created the new one, yet failed to delete old one),
     * user/customer might have multiple email_addresses, but we can easily figure out the latest one 
     * by check the activate_in_epoch
     * 
     * @param principal @Nullable
     * @return
     * @throws ValidationException if request is invalid
     * @throws ItemNotFoundException if the principal does not exist in the table
     * @throws StaleDataException if the server detected stale data for this request (only when checkStaleness flag is set true)
     * @throws RepositoryServerException internal server error
     */
    public @Nonnull String getEmailAddress(@Nullable Long principal, boolean checkStaleness) 
            throws ValidationException, ItemNotFoundException, StaleDataException, RepositoryServerException;
    
}
